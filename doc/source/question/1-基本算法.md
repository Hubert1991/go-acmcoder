# 基本算法

## 0001.股神(1)

- 题目

```
题目描述
有股神吗？
有，小赛就是！
经过严密的计算，小赛买了一支股票，他知道从他买股票的那天开始，股票会有以下变化：
第一天不变，以后涨一天，跌一天，涨两天，跌一天，涨三天，跌一天...依此类推。
为方便计算，假设每次涨和跌皆为1，股票初始单价也为1，请计算买股票的第n天每股股票值多少钱？
输入 输入包括多组数据；每行输入一个n，1<=n<=10^9 。
样例输入
1
2
3
4
5
输出 请输出他每股股票多少钱，对于每组数据，输出一行。
样例输出
1
2
1
2
3
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n^1/2)   | O(1)       |

```go
package main

import "fmt"

func main() {
	var n int
	fmt.Scanf("%d", &n)
	res := getResult(n)
	fmt.Println(res)
}

func getResult(n int) int {
	if n <= 2 {
		return n
	}
	count := 0 // 统计下跌多少次
	target := n
	// n-2-3-4-...-
	// 每减去1次，碰到的下跌次数+1
	for i := 2; i <= n; i++ {
		if target-i > 0 {
			target = target - i
			count++
		} else {
			break
		}
	}
	return n - 2*count
}
```

## 0002.翻转数组(1)

- 题目

```
题目描述
给定一个长度为n的整数数组a，元素均不相同，问数组是否存在这样一个片段，
只将该片段翻转就可以使整个数组升序排列。其中数组片段[l,r]表示序列a[l], a[l+1], ..., a[r]。
原始数组为
a[1], a[2], ..., a[l-2], a[l-1], a[l], a[l+1], ..., a[r-1], a[r],
a[r+1], a[r+2], ..., a[n-1], a[n]，
将片段[l,r]反序后的数组是
a[1], a[2], ..., a[l-2], a[l-1], a[r], a[r-1], ..., a[l+1], a[l], 
a[r+1], a[r+2], ..., a[n-1], a[n]。
输入 第一行数据是一个整数：n (1≤n≤105)，表示数组长度。
第二行数据是n个整数a[1], a[2], ..., a[n] (1≤a[i]≤109)。
样例输入
4
2 1 3 4
输出 输出“yes”，如果存在；否则输出“no”，不用输出引号。
样例输出 yes
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 排序遍历 | O(nlog(n)) | O(n)       |

```go
package main

import (
	"fmt"
	"sort"
)

func main() {
	var n int
	fmt.Scanf("%d\n", &n)
	arr := make([]int, n)
	for i := 0; i < n; i++ {
		var temp int
		fmt.Scanf("%d", &temp)
		arr[i] = temp
	}
	res := getResult(arr)
	if res == true {
		fmt.Println("yes")
	} else {
		fmt.Println("no")
	}
}

func getResult(arr []int) bool {
	temp := make([]int, len(arr))
	copy(temp, arr)
	sort.Ints(temp)
	left, right := 0, len(arr)-1
	for left < len(arr) && arr[left] == temp[left] {
		left++
	}
	if left == len(arr) {
		return false
	}
	for 0 <= right && arr[right] == temp[right] {
		right--
	}
	for i := left; i < right; i++ {
		if arr[i] < arr[i+1] {
			return false
		}
	}
	return true
}
```

## 0003.约德尔测试(1)

- 题目

```
题目描述
兰博和提莫闲聊之后，回归到了他们的正题，约德尔人的未来。
说起约德尔人的未来，黑默丁格曾经提出了一个约德尔测试，将约德尔人的历史的每个阶段都用一个字符表达出来。
(包括可写字符,不包括空格。)。然后将这个字符串转化为一个01串。
转化规则是如果这个字符如果是字母或者数字，这个字符变为1,其它变为0。
然后将这个01串和黑默丁格观测星空得到的01串做比较，得到一个相似率。相似率越高,则约德尔的未来越光明。
请问:相似率为多少？
输入 每组输入数据为两行，第一行为有关约德尔人历史的字符串，第二行是黑默丁格观测星空得到的字符串。
(两个字符串的长度相等,字符串长度不小于1且不超过1000。)
样例输入
@!%12dgsa
010111100
输出 输出一行，在这一行输出相似率。用百分数表示。
(相似率为相同字符的个数/总个数,精确到百分号小数点后两位。printf("%%");输出一个%。)
样例输出
66.67%
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n)       | O(1)       |

```go
package main

import "fmt"

func main() {
	var a, b string
	fmt.Scanf("%s\n%s", &a, &b)
	res := getResult(a, b)
	fmt.Printf("%.2f%%\n", res)
}

func getResult(a, b string) float64 {
	n := len(a)
	count := 0
	for i := 0; i < n; i++ {
		c := 0
		d := int(b[i] - '0')
		if ('0' <= a[i] && a[i] <= '9') ||
			('a' <= a[i] && a[i] <= 'z') ||
			('A' <= a[i] && a[i] <= 'Z') {
			c = 1
		}
		if c == d {
			count++
		}
	}
	return float64(count) / float64(n) * 100
}
```

## 0004.路灯(1)

- 题目

```
题目描述
V先生有一天工作到很晚，回家的时候要穿过一条长l的笔直的街道，这条街道上有n个路灯。
假设这条街起点为0，终点为l，第i个路灯坐标为ai。
路灯发光能力以正数d来衡量，其中d表示路灯能够照亮的街道上的点与路灯的最远距离，所有路灯发光能力相同。
为了让V先生看清回家的路，路灯必须照亮整条街道，又为了节省电力希望找到最小的d是多少？
输入 输入两行数据，
第一行是两个整数：路灯数目n (1≤n≤1000)，街道长度l (1 ≤l≤109)。
第二行有n个整数ai (0 ≤ ai≤ l)，表示路灯坐标，多个路灯可以在同一个点，也可以安放在终点位置。
样例输入
7 15
15 5 3 7 9 14 0
输出 输出能够照亮整个街道的最小d，保留两位小数。
样例输出
2.50
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 排序遍历 | O(nlog(n)) | O(n)       |

```go
package main

import (
	"fmt"
	"sort"
)

func main() {
	var n, l int
	fmt.Scanf("%d %d\n", &n, &l)
	arr := make([]int, n)
	for i := 0; i < n; i++ {
		var temp int
		fmt.Scanf("%d", &temp)
		arr[i] = temp
	}
	res := getResult(arr, l)
	fmt.Printf("%.2f\n", res)
}

func getResult(arr []int, l int) float64 {
	sort.Ints(arr)
	maxValue := 0
	for i := 1; i < len(arr); i++ {
		maxValue = max(maxValue, arr[i]-arr[i-1])
	}
	left := arr[0]
	right := l - arr[len(arr)-1]
	res := max(maxValue, left*2)
	res = max(res, right*2)
	return float64(res) / float64(2)
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

## 0005. 计算器的新功能

### 题目

```
题目描述
当你学一些可视化程序设计语言时，老师经常会让你设计并且编程做出一个计算器，
这时也许你会仿照windows系统自带的计算器外观和功能去设计，但是现在老师要你多做出一个有新功能的计算器，
实现当输入一个数时，能够将这个数分解成一个或多个素因子乘积的形式，并按素因子的大小排列显示出来。
大家对计算器中数的表示应该很清楚的。
下面显示出了0 — 9这十个数字的表示形式。每个数字都占据5 * 3大小的字符区域
你能实现这个新功能吗？试试看吧！
输入 输入有多组测试数据，每组包括一个正整数n（1 < n <= 1000000)。
样例输入
10
2
输出 对于每个数，将它分解成若干个素数乘积的形式，并按从小到大的顺序输出，素因子之间用“ * ”的形式连接。
样例输出
 -     -

  |   |

 -  *  -

|       |

 -     -
 -
  |
 -
|
 -
```

### 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 排序遍历 | O(nlog(n)) | O(n)       |

```go

```

## 0006.公交车乘客(1)

- 题目

```
题目描述
一个公交车经过n个站点，乘客从前门上车，从后门下车。
现在统计了在第i个站，下车人数a[i]，以及上车人数b[i]。
问公交车运行时候车上最多有多少乘客
输入 第一行读入一个整数n(1<=n<=100)，表示有n个站点
接下来n行，每行两个数值，分别表示在第i个站点下车人数和上车人数
样例输入
4
0 3
2 5
4 2
4 0
输出 每组输出车上最多的乘客数目
样例输出
6
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n)       | O(n)       |

```go
package main

import "fmt"

func main() {
	var n int
	fmt.Scan(&n)
	arrA := make([]int, n)
	arrB := make([]int, n)
	for i := 0; i < n; i++ {
		var a, b int
		fmt.Scan(&a, &b)
		arrA[i] = a
		arrB[i] = b
	}
	res := getResult(arrA, arrB)
	fmt.Println(res)
}

func getResult(a, b []int) int {
	sum := 0
	res := 0
	for i := 0; i < len(a); i++ {
		sum = sum + b[i] - a[i]
		if sum > res {
			res = sum
		}
	}
	return res
}
```

## 0007.分苹果(2)

- 题目

```
题目描述
果园里有堆苹果，N（1＜N＜9）只熊来分。第一只熊把这堆苹果平均分为N份，多了一个，
它把多的一个扔了，拿走了一份。第二只熊把剩下的苹果又平均分成N份，又多了一个，
它同样把多的一个扔了，拿走了一份，第三、第四直到第N只熊都是这么做的，问果园里原来最少有多少个苹果？
输入 输入1个整数，表示熊的个数。它的值大于1并且小于9。
样例输入
5
输出 为1个数字，表示果园里原来有的苹果个数。
样例输出
3121
```

- 解题思路

| No.  | 思路   | 时间复杂度 | 空间复杂度 |
| ---- | ------ | ---------- | ---------- |
| 01   | 数学   | O(n)       | O(1)       |
| 02   | 暴力法 | O(n^2)     | O(1)       |

```go
package main

import "fmt"

func main() {
	var n int
	fmt.Scan(&n)
	res := getResult(n)
	fmt.Println(res)
}

// res = n^n-n+1
func getResult(n int) int {
	res := 1
	for i := 1; i <= n; i++ {
		res = res * n
	}
	return res - n + 1
}

# 2
package main

import (
	"fmt"
)

func main() {
	var n int
	fmt.Scan(&n)
	res := getResult(n)
	fmt.Println(res)
}

func getResult(n int) int {
	for i := 1; ; i++ {
		target := i
		bear := n
		for bear > 0 {
			if (target-1)%n == 0 {
				bear--
				target = target - 1 - (target-1)/n
			} else {
				break
			}
		}
		if bear == 0 {
			return i
		}
	}
	return 0
}
```

## 0008.马路上的路灯(1)

- 题目

```
题目描述
城市E的马路上有很多路灯，每两个相邻路灯之间的间隔都是1公里。
小赛是城市E的领导，为了使E城市更快更好的发展，需要在城市E的一段长度为M的主干道上的一些区域建地铁。
这些区域要是建了地铁，就需要挪走相应的路灯。
可以把长度为M的主干道看成一个数轴，一端在数轴0的位置，另一端在M的位置；数轴上的每个整数点都有一个路灯。
要建地铁的这些区域可以用它们在数轴上的起始点和终止点表示，
已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。
现在要把这些区域中的路灯（包括区域端点处的两个路灯）移走。
你能帮助小赛计算一下，将这些路灯移走后，马路上还有多少路灯？
输入 输入文件的第一行有两个整数M（1 <= M <= 10000）和 N（1 <= N <= 100），M代表马路的长度，
N代表区域的数目，M和N之间用一个空格隔开。
接下来的N行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。
所有输入都为整数。且M和N的范围为上面提示范围。
样例输入
500 3
100 200
150 300
360 361
输出 输出文件包括一行，这一行只包含一个整数，表示马路上剩余路灯的数目。
样例输出
298
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 遍历 | O(n)       | O(n)       |

```go
package main

import "fmt"

func main() {
	var M, N int
	fmt.Scan(&M, &N)
	arr := make([][2]int, N)
	for i := 0; i < N; i++ {
		var a, b int
		fmt.Scan(&a, &b)
		arr[i] = [2]int{a, b}
	}
	res := getResult(arr, M)
	fmt.Println(res)
}

func getResult(arr [][2]int, M int) int {
	temp := make([]int, M+1)
	for i := 0; i < len(arr); i++ {
		a, b := arr[i][0], arr[i][1]
		for j := a; j <= b; j++ {
			temp[j] = 1
		}
	}
	res := 0
	for i := 0; i <= M; i++ {
		if temp[i] == 0 {
			res++
		}
	}
	return res
}
```

## 0009.日期倒计时(1)

- 题目

```
题目描述
在经济、科技日益发达的今天，人们对时间的把握越来越严格，对于一个一定影响力的公司的高管来说，
他可能要将自己的行程提前安排到下个月。
对于普通人来说，他也可能将几天之后的安排已经提前做好。
请设计一个程序计算出今天距离未来的某一天还剩多少天。
假设今天是2015年10月18日。
输入 输入一个日期格式为yyyy-MM-dd，不考虑日期是否小于今天。
样例输入
2015-10-19
输出 输出一个数字表示今天（2015年10月18日）距离该日期还剩多少天。
样例输出
1
```

- 解题思路

| No.  | 思路     | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| 01   | 内置函数 | O(1)       | O(1)       |

```go
package main

import (
	"fmt"
	"strconv"
	"strings"
	"time"
)

func main() {
	var end string
	fmt.Scan(&end)
	res := getResult("2015-10-18", end)
	fmt.Println(res)
}

func getResult(start, end string) int {
	arr := strings.Split(end, "-") // 转换格式 2016-1-1 => 2016-01-01
	end = fmt.Sprintf("%04d-%02d-%02d", transfer(arr[0]), transfer(arr[1]), transfer(arr[2]))
	startTime, _ := time.Parse("2006-01-02", start)
	endTime, _ := time.Parse("2006-01-02", end)
	return int(endTime.Unix()-startTime.Unix()) / (24 * 60 * 60)
}

func transfer(s string) int {
	res, _ := strconv.Atoi(s)
	return res
}
```

## 0010.比大小

### 题目

```
题目描述
现在有"abcdefghijkl”12个字符，将其所有的排列中按字典序排列，给出任意一种排列，
说出这个排列在所有的排列中是第几小的？
输入 第一行有一个整数n（0＜n＜=10000）;
随后有n行，每行是一个排列；
样例输入
3
abcdefghijkl
hgebkflacdji
gfkedhjblcia
输出
输出一个整数m，占一行，m表示排列是第几位；
样例输出
1
302715242
260726926
```

### 解题思路

```go

```

## 0011.约会(1)

- 题目

```
题目描述
Bob和Alice有个约会，一大早Bob就从点(0,0)出发，前往约会地点(a,b)。Bob没有一点方向感，
因此他每次都随机的向上下左右四个方向走一步。简而言之，如果Bob当前在(x,y)，
那么下一步他有可能到达(x+1,y),(x-1,y),(x,y+1), (x,y-1)。
很显然，当他到达目的地的时候，已经很晚了，Alice早已离去。
第二天，Alice质问Bob为什么放她鸽子，Bob说他昨天花了s步到达了约会地点。Alice怀疑Bob是不是说谎了。
你能否帮她验证一下？
输入 输入三个整数a,b,s (-109
样例输入
5 5 11
输出 输出“Yes”，如果Bob可能用s步到达(a,b)；否则输出“No”，不需要输出引号。
样例输出
No
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 数学 | O(1)       | O(1)       |

```go
package main

import (
	"fmt"
)

func main()  {
	var a, b, s int
	fmt.Scan(&a, &b, &s)
	res := getResult(a, b, s)
	if res == true{
		fmt.Println("Yes")
	}else {
		fmt.Println("No")
	}
}

func getResult(a,b,s int) bool  {
	a = abs(a)
	b = abs(b)
	if  a+b <= s && (s-a-b) % 2== 0{ // 注意2个条件
		return true
	}
	return false
}

func abs(a int) int  {
	if a < 0{
		return -a
	}
	return a
}
```

## 0012.研究生考试(1)

- 题目

```
题目描述
欢迎大家参加奇虎360 2016校招在线招聘考试，首先预祝大家都有个好成绩!
我相信参加本次在线招聘考试的有不少研究生同学。我们知道，就计算机相关专业来说，
考研有4门科目，分别是政治（满分100分），英语（满分100分），数学（满分150分）和专业课（满分150分）。
某校计算机专业今年录取研究生的要求是：政治、英语每门课成绩不低于60分，数学和专业课不低于90分，
总成绩不低于310分。
并且规定：在满足单科以及总成绩最低要求的基础上，350分以上（含350分）为公费（Gongfei），
310分~349分为自费(Zifei)。
请编程判断考生的录取情况。
输入 输入数据首先包括一个正整数N，表示有N组测试数据。
每组数据包含4个正整数，分别表示考生的四门课成绩（顺序为：政治、英语、数学、专业课），
你可以假设所有的分数数据都合法。
样例输入
3
61 62 100 120
80 80 120 100
55 90 130 130
输出 请输出每组数据对应考生的录取情况（Fail/Zifei/Gongfei）。
样例输出
Zifei
Gongfei
Fail
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 数学 | O(1)       | O(1)       |

```go
package main

import "fmt"

func main() {
	var n int
	fmt.Scan(&n)
	for i := 0; i < n; i++ {
		var a, b, c, d int
		fmt.Scan(&a, &b, &c, &d)
		sum := a + b + c + d
		if a < 60 || b < 60 || c < 90 || d < 90 || sum < 310 {
			fmt.Println("Fail")
		} else if sum >= 310 && sum <= 349 {
			fmt.Println("Zifei")
		} else {
			fmt.Println("Gongfei")
		}
	}
}
```

## 0013.行编辑器(1)

- 题目

```
题目描述
你知道行编辑器吗？不知道也没关系，现在我会告诉你：
1.如果你收到一个
输入 第一行是一个整数T，代表有T组数据。
每组数据的开始时一个字符串，字符串长度小于100，每个字符一定是(
样例输入
3
whli##ilr#e(s#*s)
outcha@putchar(*s=#++)
returnWA##A!!##C
输出 每组数据输出一行经过行编辑器编辑过的字符串，具体可以看样例。
样例输出
while(*s)
putchar(*s++)
returnAC
```

- 解题思路

| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---------- | ---------- |
| 01   | 栈   | O(n)       | O(n)       |

```go
package main

import "fmt"

func main() {
	var n int
	fmt.Scan(&n)
	for i := 0; i < n; i++ {
		var str string
		fmt.Scan(&str)
		res := getResult(str)
		fmt.Println(res)
	}
}

func getResult(str string) string {
	res := make([]byte, 0)
	for i := 0; i < len(str); i++ {
		if str[i] == '@' {
			res = make([]byte, 0)
		} else if str[i] == '#' {
			if len(res) > 0 {
				res = res[:len(res)-1]
			}
		} else {
			res = append(res, str[i])
		}
	}
	return string(res)
}
```

